Azure App Service

Azure 应用服务是一项基于 HTTP 的服务，用于托管 Web 应用程序、REST API 和移动后端 。 可以使用自己偏好的编程语言或框架进行开发。 在基于 Windows 和 Linux 的环境中，应用程序都可以轻松地运行和缩放。Azure App Service 使您无需关注底层虚拟机和基础设施，只需将开发好的应用程序软件包部署到托管环境中。App Service 负责管理和维护底层资源，包括虚拟机、网络和操作系统等。

App Service 还提供了以下功能：

1. 设置自定义域名和 SSL：您可以将自定义域名添加到应用程序，并配置 SSL 证书以确保应用程序的安全和专业。
2. 弹性扩展：根据应用程序的需求轻松增加或减少计算和存储资源，以应对不断变化的负载和性能需求。
3. 性能监控：通过 Azure 应用程序内置的监控工具，您可以实时检查应用程序的性能和资源使用情况，例如分析应用程序的响应时间、错误率和其他性能指标。
4. 部署槽位（slot）：为不同的环境dev，test，prod提供不同的槽位并可以进行预热交换。


#!/bin/bash
# Replace the following URL with a public GitHub repo URL
gitrepo=https://github.com/Azure-Samples/php-docs-hello-world
webappname=mywebapp$RANDOM
# Create a resource group.
az group create
--location westeurope
--name myResourceGroup

# Create an App Service plan in `FREE` tier.
az appservice plan create
--name $webappname
--resource-group myResourceGroup
--sku FREE

# Create a web app.
az webapp create
--name $webappname
--resource-group myResourceGroup
--plan $webappname

# Deploy code from a public GitHub repository.
az webapp deployment source config
--name $webappname
--resource-group myResourceGroup
--repo-url $gitrepo
--branch master
--manual-integration

# Copy the result of the following command into a browser to see the web app.
echo http://$webappname.azurewebsites.net

在 Azure 中创建一个 Web App 时，您必须选择一个 App Service plan（包括价格层）。App Service 计划定义了您的 Web App 使用的计算资源、性能、功能和成本。根据您的 Web App 的需求（例如性能、可用性和成本），您可以选择不同的价格层（例如 Free、Basic、Standard、Premium 或 Isolated）。




-----------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------







App Service Plan

在应用服务中，应用始终在应用服务计划中运行。 应用服务计划为要运行的 Web 应用定义一组计算资源。 可将一个或多个应用配置为在相同的计算资源中（或相同的应用服务计划中）运行。
定价层
优点
缺点
免费（Free）
- 无需支付成本
- 适合学习、研究、简单的应用
- 资源限制（CPU/RAM/存储）
- 无法扩展实例数量
  共享（Shared）
- 低成本
- 适用于测试和简单的应用
- 资源限制且与其他应用共享
- 无法扩展实例数量
  基本（Basic）
- 单独的虚拟机
- 手动扩展实例
- 自定义域和 SSL 支持
- 无法自动扩展
  标准（Standard）
- 单独的虚拟机
- 自动扩展（最多 10 个实例）
- 自定义域和 SSL 支持
- 支持部署槽
- 对于大规模应用需要更高的定价层
  高级（Premium）
- 单独的虚拟机
- 自动扩展（最多 30 个实例）
- 自定义域和 SSL 支持
- 支持部署槽
- 更高的硬件规格
- 成本较高
  隔离（Isolated）
- 专用的虚拟机
- 自动扩展（最多 100 个实例）
- 自定义域和 SSL 支持
- 支持部署槽
- 更高的硬件规格
- 高级网络功能（如专用网络连接）
- 成本较高
  Consumption Plan 和 Premium Plan 是 App Service Plan 的两种特定类型，分别用于不同的应用程序使用场景。

1. Consumption Plan： Consumption Plan 主要用于 Azure Functions（无服务器计算服务），提供完全按需付费和无服务器体验。用户只需为实际执行的函数次数支付费用，而不是预先分配的资源。这种方案适用于在特定事件触发时执行特定操作的应用程序。Consumption Plan 提供了完全的自动扩展和自动缩减功能，根据函数的实际使用情况分配资源。
2. Premium Plan： Premium Plan 是适用于 Web 应用、API 应用等的一种 App Service Plan。与 Consumption Plan 不同，Premium Plan 是预先分配给应用程序的资源，而不是按实际使用付费。在 Premium 计划中，您可以获得高级功能，如虚拟网络集成、高性能计算、高可用性和持久存储等。托管较大规模应用程序或具有高级性能、安全性和功能需求的应用程序时，这是一个理想的选择。快速响应选择App Service Plan.
   Consumption Plan
   连接到 VNet
   否
   始终热启动
   否
   动态缩放
   是
   支持消耗计费
   是

Premium Plan
是
是
是
否
App Service Plan
是
是
（free,share不支持，其他级别支持）
否



1. 确定虚拟机 (VM) 的数量：每个客户都需要一个实例的 WebJob，总共有 4 个客户，因此您至少需要 4 个实例。
2. 要将 Azure 资源隔离在一个独立的网络环境中，则应该选择 "Isolated" 价格层。




Azure Functions

Azure Functions 是一种无服务器解决方案，Azure Functions 支持 触发器（用于启动代码执行）和绑定（用于简化针对输入和输出数据进行的编码）Azure Functions 有三个基本托管计划：消耗计划、高级计划和专用（应用服务）计划。函数应用需要一个支持 Azure Blob、队列、文件和表存储的常规 Azure 存储帐户。函数代码文件存储在函数主要存储帐户中的 Azure 文件共享上。 删除函数应用的主存储帐户时，函数代码文件将被删除并且无法恢复。
托管计划
优点
缺点
Consumption Plan
- 完全按需付费
- 无服务器：无需管理基础设施
- 完全自动扩展
- 函数执行时存在冷启动延迟
- 不适合持续高负载的应用程序
  Premium Plan
- 按需缩放
- 虚拟网络集成
- 无冷启动延迟
- 更高的硬件规格和性能
- 需要预先分配资源（与按需付费相比）
- 成本较高
  App Service Plan
- 支持多种编程语言和框架
- 托管 Web 和 API 应用
- 自动扩展（某些定价层）
- 需要预先分配资源（与按需付费相比）
- 函数执行时存在冷启动延迟
  请注意，Azure Functions 可以运行在 App Service Plan 中，但是这种情况下，它将失去部分无服务器体验的特点（如按需付费），并且它将收到资源和扩展的约束，这取决于选择的 App Service Plan 定价层。Consumption Plan 和 Premium Plan 是为 Azure Functions 定制的托管计划，提供了更接近于无服务器体验的特性和高级功能。



{
"version": "2.0",
"extensionBundle": {
"id": "Microsoft.Azure.Functions.ExtensionBundle",
"version": "[1.*, 2.0.0)"
},
"customHandler": {
"description": {
"defaultExecutablePath": "process.exe",
"workingDirectory": "",
"arguments": []
},
"enableForwardingHttpRequest": true
}
}

host.json 文件中的 customHandler 属性定义了自定义处理程序的配置。在这种情况下，我们将 defaultExecutablePath 设置为 "process.exe"。将 enableForwardingHttpRequest 设置为 true，以启用将传入的 HTTP 请求转发到自定义处理程序。 现在，您还需要创建一个 function.json 文件，该文件将输入和输出绑定到您的 Azure 函数以执行 C++ 应用程序。例如，假设您的 C++ 函数具有 "HttpTrigger" 作为触发器：
{
"bindings": [
{
"authLevel": "function",
"type": "httpTrigger",
"direction": "in",
"name": "req",
"methods": ["post"],
"route": "imageconv"
},
{
"type": "http",
"direction": "out",
"name": "$return"
}
]
}
在这里，我们定义了一个名为 "req" 的 HTTP 触发器，它接受以 post 方法发送的传入请求。路由(route)被设置为 "imageconv"。请求绑定到函数输入，然后与 "http" 类型的输出绑定，以便将返回数据（转换后的图像）作为 HTTP 响应返回。 通过这样的配置，您将能够成功部署 C++ 应用程序作为 Azure 函数并通过 HTTP 请求处理图像。



{
"bindings": [
{
"type": "webPubSubTrigger", //接收用户事件，触发函数
"direction": "in",
"name": "event",
"hub": "<your_hub_name>",
"eventType": "user", //表明是用户事件
"userId": "{userId}",
"connectionStringSetting": "AzureWebPubSub_ConnectionString"
},
{
"type": "webPubSub", //直接通过响应返回数据
"direction": "out",
"name": "outputMessage",
"hub": "<your_hub_name>",
"connectionId": "{connectionId}",
"connectionStringSetting": "AzureWebPubSub_ConnectionString"
}
]
}
在 Azure Web PubSub 的 Azure Functions 输入绑定（即 webPubSubTrigger 类型）中，`eventType` 可以用来指定要处理的事件类型。以下是可用的 eventType 类型：
1. `connect`: 配置为 "connect" 时，将处理客户端与 Web PubSub 服务建立连接的事件。
2. `connected`: 表示已经建立了客户端与 Web PubSub 服务之间的连接。当连接成功建立时，会触发这种类型的事件。
3. `disconnect`: 当客户端与 Web PubSub 服务断开连接时，触发这种类型的事件。
4. `disconnected`: 表示客户端已经断开与 Web PubSub 服务的连接。在连接断开后，会触发这种类型的事件。
5. `message`: 当客户端向 Web PubSub 发送消息时，触发这种类型的事件。
6. `user`: 当客户端发送自定义用户事件时（在上下文消息中指定自定义事件类型），触发这种类型的事件。


1. Premium plan (avoid any cold starts and connect to a VNet),
2. Create system-assigned => "A system-assigned identity is tied to your application and is deleted if your app is deleted."
3. create an access policy



With custom handlers, you can use triggers and input and output bindings via extension bundles.





logic app example:






Always On 功能确保了 Azure Function 和其他在 App Service 计划中托管的应用在空闲期间仍然像被激活时一样保持运行状态。
配置重试会使 Azure Function 能够在遇到失败时尝试再次执行。这对于确保当触发未成功时，函数可以有其他机会执行是很有帮助的。

如果 Azure Function 是基于 HTTP 请求触发的，在大部分情况下不需要启用 Always On 功能。当有 HTTP 请求到达时，Azure 会自动唤醒处于休眠状态的应用程序。
但是，仍有一些情况需要考虑 Always On 功能：
1. 更低的延迟
2. 后台任务


Azure Blob Store
存储帐户类型
性能
支持的服务
用例
Storage (v1)
标准（HDD）
Blob、文件、队列、表
大多数常见工作负载
StorageV2
标准（HDD）
Blob、文件、队列、表（含高级功能）,提供了hot,cool,archive层以及 Static Website Hosting和IAM权限控制
推荐的默认选择，适用于大多数工作负载
BlockBlobStorage
高级（SSD）
Blob（仅限高级 Blob 存储）
大型对象、数据湖分析场景

Premium Storage
高级（SSD）
Blob（仅限非blockBlob）
虚拟机磁盘、高性能工作负载
FileStorage
高级（SSD）
文件（仅限高级文件存储）
高性能文件共享，如虚拟机磁盘、企业文件共享等

Change Feed（更改数据流）是 Azure Blob 存储的一项功能，它可以让您获取到存储帐户中所有 Blob 数据和元数据更改的有序记录。当 Blob 存储中发生数据更改（如创建、修改、删除操作）时，这些变更信息会自动记录在 Change Feed 中。 这样，你就可以订阅这些记录并处理数据更改。 Change Feed 的主要用途：
1. 审计：让您可以跟踪 Blob 存储中所有的数据更改操作。
2. 数据同步：将 Blob 存储中的数据实时或异步同步到其他系统或服务（如备份、缓存或搜索引擎）。
3. 触发事件：为了响应数据更改而触发一些操作，例如向用户发送通知、启动工作流程等。



1. Yes：AcquireLeaseAsync does not specify leaseTime. If null, an infinite lease will be acquired. If not null, this must be 15 to 60 seconds.
2. No：The GetBlockBlobReference method just gets a reference to a block blob in this container.
3. Yes：The BreakLeaseAsync method initiates an asynchronous operation that breaks the current lease on this container.
   在azure blob存储中：
1. Blob：二进制大文件，如 Block Blob（用于处理大型文件）、Page Blob 和 Append Blob。每个 Blob 具有唯一的名称，并且在同一容器中不会有两个相同名称的 Blob。
2. Lease（租约），相当于一个进程独占整个Blob的时间，可以用于保护并发修改。
3. Container：Blob的容器，相当于文件夹，删除container时，其中所有的 Blob 会自动删除。

Azure Blob 存储的归档层访问数据时，恢复时间可能需要长达数小时，通常在 1 小时至 15 小时之间。这是因为归档层通常用于长期存储、不需要经常访问和性能不敏感的数据。归档层的主要优势是极低的存储成本











当客户端发送请求以处理 Change Feed 时，服务器会返回一个 continuationToken。客户端在下一次请求时将这个 continuationToken 发送回服务器，以便从上次请求结束的地方继续处理变更。这样可以确保客户端始终从最近处理过的位置开始，从而避免漏读或重复处理事件。



1. 自定义域名：您可以将自定义域名映射到 Azure CDN 端点，并将其与静态网站关联。这样，用户就可以通过自定义域名访问您的网站。
2. 自定义响应头：您可以使用 Azure CDN 规则引擎为所有响应添加自定义头。这样，所有通过 CDN 经过的请求都会返回您定义的自定义头。
3. 自定义 SSL 证书：Azure CDN 允许您使用自己的 SSL 证书或由 CDN 管理的证书。您可以将证书与自定义域关联，从而为静态网站提供HTTPS加密。


要让 Azure Functions 在仅上传图像时触发，可以通过限制 Blob 触发器路径中的文件扩展名。在此情况下，选择 D 选项， 即 "samples-workitems/{name}.png"，将确保仅在上传 PNG 格式的图像时触发 Azure Function。这里的 {name} 占位符将与实际上传的文件名匹配。



Azure Container
Azure 容器注册表（Azure Container Registry, ACR）和 Helm Charts 分别用于在 Kubernetes 集群中部署和管理容器镜像和应用程序。它们之间的关系可概括如下：

1. Azure 容器注册表（ACR）是一个用于存储和管理 Docker 容器镜像的托管服务。在将应用程序部署到 Kubernetes 集群（如 Azure Kubernetes 服务，AKS）之前，需要将容器镜像推送到 ACR 或其他容器镜像仓库（如 Docker Hub）。ACR 主要负责管理容器镜像和版本。它允许私有访问，可以根据用户需求扩展存储。
2. Helm Charts是一种用于在 Kubernetes 集群中部署和管理应用程序的工具。Charts 是 Helm 使用的预先打包的、可配置的 Kubernetes 资源集合，其中之一就是镜像配置。

在实际应用中，您可能会这样操作：

1. 将容器镜像推送到 Azure 容器注册表（ACR）。
2. 创建 Helm Chart，其中配置从 ACR 拉取容器镜像。
3. 使用 Helm 将配置好的 Chart 部署到 Kubernetes 集群。

总之，Azure 容器注册表 (ACR) 负责存储和管理容器镜像，而 Helm Charts 负责部署、 配置和更新应用程序到Kubernetes集群中。在部署应用程序时，Helm Chart 使用在 ACR 中存储的镜像。Helm chart会包含需要的所有资源：
my-application-chart/
│   Chart.yaml        # 包含 Chart 基本信息，如名称、版本
│   values.yaml       # 默认配置文件，包含模板中使用的变量值
│
├── templates/
│   ├── java-deployment.yaml       # Java 程序的 Deployment 资源模板
│   ├── java-service.yaml          # Java 程序的 Service 资源模板
│   ├── mysql-statefulset.yaml     # MySQL 数据库的 StatefulSet 资源模板
│   ├── mysql-service.yaml         # MySQL 数据库的 Service 资源模板
│   ├── redis-statefulset.yaml     # Redis 数据库的 StatefulSet 资源模板
│   └── redis-service.yaml         # Redis 数据库的 Service 资源模板
│
└── charts/
├── mysql      # MySQL 的子 Chart（可选，如果需要高级定制）
└── redis      # Redis 的子 Chart（可选，如果需要高级定制）

ACI azure container instances
启动aci命令：

az container create
--resource-group myResourceGroup
--name mycontainer2
--image mcr.microsoft.com/azuredocs/aci-wordcount:latest
--restart-policy OnFailure
--environment-variables 'NumWords'='5' 'MinLength'='8'
--ports 80
--dns-name-label $DNS_NAME_LABEL
--location <myLocation>

如果环境变量中有敏感数据，可以使用key vault来保证其私密性：

{
"apiVersion": "2018-10-01",
"type": "Microsoft.ContainerInstance/containerGroups",
"name": "your-container-group",
"properties": {
"containers": [
{
"name": "your-container",
"properties": {
"image": "your-image",
"environmentVariables": [
{
"name": "YOUR_SENSITIVE_DATA",
"secureValue": "@Microsoft.KeyVault(SecretName=MyConnection;VaultName=MyVault)"
}
]
}
}
]
}
}

ACA azure container app
特性
Azure Container Instances (ACI)
Azure Container Apps
相同点
容器托管
容器托管

支持使用 Docker 镜像
支持使用 Docker 镜像

集成 Azure
集成 Azure
不同点
基本的容器管理功能（例如创建、运行、删除）
自动扩展支持

仅支持 Azure CLI 和 REST API
事件驱动编程模型

适用于无状态应用程序
提供侧车

无原生自动扩展支持
集成原生 Azure 服务（如 Functions、Logic Apps 等）
应用场景
短暂的任务和应用程序（例如CI/CD、ETL 任务、批处理任务）
需要高度可靠性、弹性和可扩展性的长时间运行应用程序（如 Web 应用程序、API、缓存等）

无状态、快速启动的服务
无服务器应用程序托管
az containerapp create \
--name my-container-app \
--resource-group $myRG \
--environment $myAppContEnv \
--image mcr.microsoft.com/azuredocs/containerapps-helloworld:latest \
--target-port 80 \
--ingress 'external' \
--query properties.configuration.ingress.fqdn

使用 az containerapp update 命令，可以修改环境变量、计算资源、缩放参数和部署其他映像。 如果容器应用更新包含修订范围更改，则生成新的修订。

az containerapp update \
--name <APPLICATION_NAME> \
--resource-group <RESOURCE_GROUP_NAME> \
--image <IMAGE_NAME>

可以使用 az containerapp revision list 命令列出与容器应用关联的所有修订。

az containerapp revision list \
--name <APPLICATION_NAME> \
--resource-group <RESOURCE_GROUP_NAME> \
-o table




Container group is the only logical answer that can have shared lifecycl
Azure files need root permission
EmtyDir can persist through crash and redeployed on stop and restart

Azure File Share: only one to support SMB


# Set the base image to use the official Microsoft .NET Core runtime image
FROM mcr.microsoft.com/dotnet/core/runtime:latest

# Set the working directory to /app
WORKDIR /app

# Copy setupScript.ps1 and ContosoApp.dll into the container's /app directory
COPY setupScript.ps1 ContosoApp.dll ./

# Run the setupScript.ps1 when building the container
RUN powershell -File ./setupScript.ps1

# Command to run ContosoApp.dll when the container starts
CMD ["dotnet", "ContosoApp.dll"]

可以将 CMD 放在 RUN 前面。Dockerfile 的命令顺序实际上不会影响启动容器时的行为。但是，通常我们按实际执行顺序（从构建镜像到运行容器）对 Dockerfile 进行编排，以使其更容易阅读和理解



1. 共享模式无法扩展实例数量，windows不支持多容器
2. 版本固定就需要确定版本号，然后通过image name获取
3. --docker-registry-server-url images.azurecr.io: 指定您的 Azure 容器注册表 (ACR) 登录服务器。其中，images.azurecr.io 是您的 ACR 实例的登录服务器域名。 添加了 /website Azure Web App 是无法识别该 URL 的。







需要最小化写入延迟且存储的内容能够在 Pod 重启时保持不变。在这种情况下，azure-disk 是更合适的选择，因为它能提供更高的性能和更低的写入延迟。然而，需要说明的是，尽管 'azure-file' 的性能略逊于 'azure-disk'，但在某些场景下，例如多个 Pod 同时读写数据的情况，您也可以考虑使用 'azure-file'


* StorageClass：代表存储的类型或类别，它定义了可以用于动态创建 PersistentVolume 的供应程序、特定于供应程序的参数、访问模式等。它可以对外部存储系统（例如，AWS EBS、Azure Disk Storage、网络存储服务器上的 NFS、Ceph 或 GlusterFS等）进行抽象，便于集群管理员自定义存储类型并隐藏底层的配置细节。
* PersistentVolume（PV）：表示集群中可用的存储资源及其限制，如总容量和访问模式。PV 可以是手动创建并配置的，也可以根据 StorageClass 自动创建。
* PersistentVolumeClaim（PVC）：表示单个 Pod 对存储的需求，它描述了 Pod 所需的存储容量和访问模式。一个 PVC 请求绑定到一个合适的 PV，以便将 PV 提供的存储空间挂载到 Pod 的容器中。
  apiVersion: storage.k8s.io/v1
  kind: StorageClass
  metadata:  name: azure-disk-storage
  provisioner: kubernetes.io/azure-disk
  parameters:  storageaccounttype: Standard_LRS
  kind: Managed


apiVersion: v1
kind: PersistentVolume
metadata:  name: my-pv
spec:  capacity:    storage: 10Gi
accessModes:    - ReadWriteOnce
hostPath:    path: /var/local/my-storage


apiVersion: v1
kind: PersistentVolumeClaim
metadata:  name: my-pvc
spec:  accessModes:    - ReadWriteOnce
storageClassName: azure-disk-storage
resources:    requests:      storage: 10G





Kind
独特字段
简要说明
Pod
spec.containers
Pod 中运行的容器列表（包括容器名称、镜像和端口等）
Service
spec.ports, spec.selector
服务要暴露的端口和目标 Pods 的选择器
Deployment
spec.template
部署的 Pod 模板（包括容器配置、环境变量等）
ReplicaSet
spec.replicas
所需的 Pod 副本数量
StatefulSet
spec.serviceName
用作生成网络标识的 headless service 的名称
DaemonSet
spec.template
DaemonSet 的 Pod 模板（类似于 Deployment 的模板）
ConfigMap
data
以 key-value 形式存储非机密配置数据的字段
Secret
data, stringData
以 base64 编码（data）或字符串（stringData）形式存储敏感数据
PersistentVolume
spec.capacity
物理存储空间的容量信息
PersistentVolumeClaim
spec.resources.requests
请求的存储空间量（对应 PersistentVolume 的 spec.capacity）
Job
spec.template
定义单次运行成功结束任务的 Pod 模板
CronJob
spec.schedule, spec.jobTemplate
定时计划表达式和要执行的任务（Job）的模板
Namespace
metadata.name
定义命名空间名称
Ingress
spec.rules
路由规则及其他代理配置项
HorizontalPodAutoscaler
spec.minReplicas, spec.maxReplicas, spec.metrics
最小副本数量，最大副本数量，缩放度量（如 CPU 使用率）
NetworkPolicy
spec.podSelector, spec.ingress, spec.egress
网络策略适用的 Pod 选择器、允许的入站和出站连接规则
StorageClass
provisioner, parameters
定义存储类型（如 gp2/aws-ebs 等）以及其他相应的配置参数




Azure Resource Template


az ts 命令用于在 Azure 中创建、管理和部署模板规范（Template Specs）。当您需要使用 ARM（Azure Resource Manager）模板来编排 Azure 资源部署时，可以使用 az ts 命令。

创建模板
az ts create
--name "your_template_spec_name"
--version "1.0"
--resource-group "your_resource_group"
--location "your_location"
--template-file "C:\templates\mainTemplate.json"
--version-description "First version"
* 使用 --name 指定模板规范的名称。
* 使用 --version 指定模板规范的版本。
* 使用 --resource-group 指定资源组的名称。
* 使用 --location 指定资源组的位置。
* 使用 --template-file 指定 mainTemplate.json 文件的路径。
* 使用 --version-description 提供版本描述。

部署模板（部署时才会用parameter）
获取模板规范的 ID：
templateSpecId=$(
az ts show
--name "your_template_spec_name"
--version "1.0"
--resource-group "your_resource_group"
--query 'id' -o tsv)

使用 az deployment（订阅级别部署）或者 az deployment group（资源组级别部署）部署模板规范。在这里，我们以资源组级别部署为例：
az deployment group create
--resource-group "your_deployment_resource_group"
--template-spec $templateSpecId
--parameters "C:\templates\mainTemplate.parameters.json"
* 使用 --resource-group 指定部署目标资源组的名称。
* 使用 --template-spec 参数引用之前获取的模板规范 ID。
* 使用 --parameters 参数指定 mainTemplate.parameters.json 文件的路径


1. Key Vault + Access Policy. Using Key Vault we create a secret containing our Password: https://docs.microsoft.com/en-us/azure/key-vault/secrets/quick-create-portal .
2. Using an Access Policy we allow access to the previously created secret.


platformFaultDomainCount 属性用于指定 Azure 可用性集中故障域（Fault Domain）的数量。故障域（Fault Domain）在同一个数据中心内的不同物理机上对服务器和相关硬件进行组织。这样，在一个故障域内的硬件发生问题时（例如电源故障、网络问题等），其他故障域中的硬件和虚拟机不会受到影响，从而确保应用程序和服务的高可用性。通过将虚拟机分布在同一数据中心的多个故障域中，您可以降低它们由于底层硬件故障而中断的风险。


将 platformUpdateDomainCount 设置为2表示您的虚拟机将分布在2个不同的更新域（用于规模集或可用性集）中。这样，如果其中一个更新域中的虚拟机由于平台维护而不可用，另一个更新域中的资源仍然可以运行。








